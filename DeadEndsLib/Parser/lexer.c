//
//  DeadEnds Library
//  lexer.c has the lexer functions for DeadEnds script programs.
//
//  Created by Thomas Wetmore on 27 December 2022.
//  Last changed on 18 June 2025.
//

#include "lexer.h"
#include "y.tab.h"  // Generated by yacc or bison when processing yacc.y.

static int getToken(void);    // Instrumentable lexing function.
static int getTokenLow(void); // The lexing function.
static int inchar(void);      // Get the next character from the current file.
static void unreadchar(int c);  // Unread a character to the current file.
static bool reserved(String word, int *pval);  // Check whether an identifier is reserved.

// Global variables.
extern FILE* currentFile; // Current FILE* being parsed.
extern int curLine;; // Current line number in file being parsed.

// Define yylval here for now.
extern SemanticValue yylval;  // Defined in y.tab.c

static bool debugging = false; 

// yylex is the interface to the yacc-generated parser. Returns an integer as the token type,
// and in some cases sets yylval as the token value.
int yylex(void) {
    return getToken();
}

// getToken returns the next token; it calls the real lexer, allowing any instrumentation to be
// added here.
static int getToken(void) {
    int tokenType = getTokenLow();
    if (debugging) {
        if (tokenType < 128) {
            printf("token: %c\n", tokenType);
            return tokenType;
        }
        switch (tokenType) {
            case IDEN: printf("token: %s\n", yylval.string); break;
            case ICONS: printf("token: %ld\n", yylval.integer); break;
            case SCONS: printf("token: %s\n", yylval.string); break;
            case FCONS: printf("token: %g\n", yylval.floating); break;
            default: printf("resrv: %s\n", yylval.string); break;
        };
    }
    return tokenType;
}

// getTokenLow is the real lexer.
static int getTokenLow(void) {
    int retval;
    CharType t; // Type of current character.
    int c; // Current character.
    static char tokbuf[512]; // Buffer where tokens accumulate.

    char* p = tokbuf; // Pointer to current point in tokbuf.
    // Get by white space, including comments.
    while (true) {
        while ((t = characterType(c = inchar())) == White)
            ;
        if (c != '/') break; // Passed any whitespace not followed by a comment.
        // Handle comment if there.
        if ((c = inchar()) != '*') {
            // Not in comment. Unread last character and return /.
            unreadchar(c);
            return '/';
        }
        // Found the start of a comment. Read to its end.
        while (true) {
            while ((c = inchar()) != '*' && c != 0) ;  // Read to a *.
            if (c == 0) return 0;
            while ((c = inchar()) == '*') ;  // Allow multiple *'s.
            if (c == '/') break;
            if (c == 0) return 0;
            // Anything else continues the comment finding loop.
        }
    }

    // Got by any white space and/or comments. Now at the first character of a token.
    if (t == Letter) {
        p = (String) tokbuf;
        while (t == Letter || t == Digit || c == '_') {
            *p++ = c;
            t = characterType(c = inchar());
        }
        *p = 0;
        unreadchar(c);
        //printf("in lexer.c -- IDEN is %s\n", tokbuf);
        yylval.string = strsave((String) tokbuf);  // TODO: RESERVED WORDS GETTING IN THERE TOO
        // See if the IDEN is a reserved word.
        if (reserved((String) tokbuf, &retval)) return retval;
        return IDEN;
    }

    // Handle numbers. They can be positive or negative. They can be integers or floating point.
    if (c == '-' || t == Digit || c == '.') {
        bool whole = false;
        bool frac = false;
        int mul = 1;
        if (c == '-') {  // Hyphen could be a hypnen or a minus sign in front of a number.
            t = characterType(c = inchar());  // Read the next character to find out.
            if (c != '.' && t != Digit) {
                unreadchar(c);
                return '-';
            }
            mul = -1;
        }
        int ivalue = 0;
        while (t == Digit) {
            whole = true;
            ivalue = ivalue*10 + c - '0';  // Accumulate the integer part of the number.
            t = characterType(c = inchar());
        }

        // If the next character is not Period an integer was read.
        if (c != '.') {
            unreadchar(c);
            ivalue *= mul;
            yylval.integer = ivalue;
            return ICONS;
        }

        // Just read . at end of integer. Read next character to see what's up.
        t = characterType(c = inchar());
        float fvalue = 0.0;
        float fdiv = 1.0;
        while (t == Digit) {
            frac = true;
            fvalue = fvalue*10 + c - '0';
            fdiv *= 10;
            t = characterType(c = inchar());
        }

        // Unread character after last digit.
        unreadchar(c);
        if (!whole && !frac) {  // Is this possible.
            unreadchar(c);
            if (mul == -1) {
                unreadchar('.');
                return '-';
            } else
                return '.';
        }
        yylval.floating = mul*(ivalue + fvalue/fdiv);
        return FCONS;
    }

    // Handle string constants.
    if (c == '"') {
        p = tokbuf;
        while (true) {
            c = inchar();
            if (c == 0 || c == '"') {
                *p = 0;
                yylval.string = strsave(tokbuf);
                return SCONS;
            }
            if (c == '\\') {
                // Escape sequence
                c = inchar();
                switch (c) {
                    case 'n': *p++ = '\n'; break;
                    case 't': *p++ = '\t'; break;
                    case 'v': *p++ = '\v'; break;
                    case 'r': *p++ = '\r'; break;
                    case 'b': *p++ = '\b'; break;
                    case 'f': *p++ = '\f'; break;
                    case '"': *p++ = '"'; break;
                    case '\\': *p++ = '\\'; break;
                    case 0:
                        *p = 0;
                        yylval.string = strsave(tokbuf);
                        return SCONS;
                    default:
                        *p++ = c; break;
                }
            } else {
                // Normal character
                *p++ = c;
            }
        }
    }
    if (c == 0) return 0;
    return c;
}

// inchar gets the next character from the Lexer.
static int inchar(void) {
    int c = getc(currentFile);
    if (c == '\n') curLine++;
    if (debugging) printf("+: '%c'\n", c);
    return c == EOF ? 0 : c;
}

// unreadchar returns a character to the lexer.
static void unreadchar(int c) {
    if (c == 0) return;
    if (debugging) printf("-: '%c'\n", c);
    ungetc(c, currentFile);
    if (c == '\n') curLine--;
}

// rwordtable is the reserved word table; keep in alphabetical order.
static struct {
    char* rword;
    int val;
} rwordtable[] = {
    { "break",    BREAK },
    { "call",     CALL },
    { "children",  CHILDREN },
    { "continue",  CONTINUE },
    { "else",     ELSE },
    { "elsif",    ELSIF },
    { "families", FAMILIES },
    { "fathers",  FATHERS },
    { "foreven",  FOREVEN },
    { "forfam",   FORFAM },
    { "forindiset",  FORINDISET },
    { "forindi",  FORINDI },
    { "forlist",  FORLIST_TOK },
    { "fornodes", FORNODES },
    { "fornotes", FORNOTES },
    { "forothr",  FOROTHR },
    { "forsour",  FORSOUR },
    { "func",     FUNC_TOK },
    { "if",       IF },
    { "mothers",  MOTHERS },
    { "Parents",  PARENTS },
    { "proc",     PROC },
    { "return",   RETURN },
    { "spouses",  SPOUSES },
    { "traverse", TRAVERSE },
    { "while",    WHILE },
};

static const int nrwords = ARRAYSIZE(rwordtable);

// reserved checks if a String is a reserved word.
static bool reserved (String word, int* pval) {
    for (int i = 0; i < nrwords; i++) {
        if (eqstr(word, rwordtable[i].rword)) {
            *pval = rwordtable[i].val;
            return true;
        }   
    }
    return false;
}
